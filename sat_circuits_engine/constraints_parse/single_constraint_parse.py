"""
`SingleConstraintParsed` class.
"""

from typing import List, Union, Optional

class SingleConstraintParsed:
    """
    Provides an interface for converting a string of a single constraint, written in a specific
    "low-level" format to a `SingleConstraintParsed` object that defines a specific API.
        - See `constraints_format.md` in the main directory for format details.

    The accessible API generated by this class is defined by the followingg attributes:
        constraint_index (int): the index number of the constraint.
        constraint_string (str): the single constraint's equation, in a low-level format.
        high_level_constraint_string (Optional[str] = None): the constraint's equation,
        in a high-level format, if exists.
        string_to_show: the constraint's string to use for visualization purposes.
        operator (str): the comparison operator of the constraint.
        * For the following attributes index 0 is associated with the left side of the constraint's
        equation, and index 1 is associated with the right side of the constraint's equation.
        sides_bit_indexes (List[List[List[int]]]): A list whose elements are lists that contain
        lists of bit-indexes bundles, for each side of the constraint's equation. An empty list
        is generated for an expression without any bit-indexes bundles.
        sides_int_bitstrings (List[Optional[str] = None]): a list whose elements are bitstrings
        representations of integers, that may be found from both sides of the constraint's equation.
        Defualt is None for each side that doesn't contain an integer.
    """
    
    def __init__(
        self,
        constraint_string: str,
        constraint_index: int,
        high_level_constraint_string: Optional[str] = None
    ) -> None:
        """
        Args:
            constraint_index (int): the index number of the constraint.
            constraint_string (str): the single constraint's equation, in a low-level format.
                - See `constraints_format.md` in the main directory for format details.
            high_level_constraint_string (Optional[str] = None): the constraint's equation,
            in a high-level format, if exists.
        """
        
        self.constraint_string = constraint_string
        self.constraint_index = constraint_index

        if high_level_constraint_string is None:
            self.string_to_show = constraint_string
        else:
            self.string_to_show = high_level_constraint_string

        # Handling constraint's format and setting `self.operator` (the comparison operator)
        self.parse_format()

        # Parsing the constraint's equation and storing values to attributes of the defined API
        self.parse_equation() 
    
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}('{self.string_to_show}')"
    
    def parse_format(self) -> None:
        """
        Given a single "low-level" constraint string, this method parses its format.
        The format can be either a "comparison format" (which the program can handle),
        or a "boolean format" (which needs to be translated into a digestable comparison format).

        If a boolean format is encountered this method calls for the `self.parse_boolean_format`
        method that parses it and calls for this method again with an equivalent comparison format.
        
        Saves the parsed comparison operator into an attribute called `self.operator`.
        """

         # The cases where the constraint string is in a comparison format        
        if "==" in self.constraint_string:
            self.operator = "=="
        elif "!=" in self.constraint_string:
            self.operator = "!="

        # The cases where the constraint string is in a boolean format
        elif "||" in self.constraint_string:
            self.parse_boolean_format("||")
        elif "&&" in self.constraint_string:
            self.parse_boolean_format("&&")

        # The cases where no operator present = a boolean format private case of 1 operand
        else:
            self.parse_boolean_format("&&")
            
    def parse_boolean_format(self, boolean_operator: str) -> None:
        """
        Parses a constraint in a boolean format and transforms it into a comparison format.
        Reminder from `constraints_format.md`: A valid boolean format allows only one type of binary
        boolean operators in each constraint, and each operand must be of a single bit length.

        Args:
            boolean_operator (str): The binary boolean operator in the boolean constraint's string,
            can be either "&&" (AND) or "||" (OR).

        Raises:
            SyntaxError - if an unsupported boolean binary operator is encountered.
        """

        splitted_constraint = self.constraint_string.split(boolean_operator)
        num_operands = len(splitted_constraint)

        if boolean_operator == "||":
            comparison_operator = "!="
        elif boolean_operator == "&&":
            comparison_operator = "=="
        else:
            raise SyntaxError("The only supported binary boolean operators are '||' (OR) and '&&' (AND).")

        # Translating the boolean constraint to a comparison constraint with an integer
        compared_value = 0
        for bit_index, var in enumerate(splitted_constraint):
            if (
                ("~" in var and boolean_operator == "||")
                or
                ("~" not in var and boolean_operator == "&&")
            ):
                compared_value += 2 ** ((num_operands - 1) - bit_index)

        # Transforming `self.constraint_string` from a boolean format to a comparison format
        replaced_string = (
            self.constraint_string.replace(boolean_operator, '') \
            .replace('~', '') \
            .replace(' ',  '') \
            .replace(')', '')
        )
        self.constraint_string = (
            f"{replaced_string} {comparison_operator} {compared_value})"
        )

        # Parsing the constraint's equation again, now in a comparison format
        self.parse_format()

    def parse_equation(self) -> None:
        """
        Parses a constraint's equation in a comparison format into attributes that form
        an API for this class as defined in the class' docstrings.
        """
        
        # Stripping off parentheses and redundant edge-spaces
        stripped_string = self.constraint_string.strip('() ')
        
        # Splitting the constraint into its two sides
        splitted_equation = stripped_string.split(self.operator)

        self.sides_bit_indexes = []
        self.sides_int_bitstrings = []
        
        # Iterating over the 2-sides of the constraint's equation
        for side_string in splitted_equation:

            # Operands should be separated with '+' operators
            operands = side_string.split('+')

            # Extracting bit-indexes bundles operands
            self.sides_bit_indexes.append(list(map(
                self.parse_operand,
                filter(
                    lambda x: isinstance(self.parse_operand(x), list),
                    operands
                )
            )))

            # Extracting integer bitstring operand (there should be 0 or 1 integer operands)
            try:
                self.sides_int_bitstrings.append(self.parse_operand(next(filter(
                    lambda x: isinstance(self.parse_operand(x), str),
                    operands
                ))))
            except StopIteration:
                self.sides_int_bitstrings.append(None)

    def parse_operand(self, operand_string: str) -> Union[List[int], str]:
        """
        Parses a single operand's string.

        Args:
            operand_string (str): a single operand's string.

        Returns:
            (Union[List[int], str]):
                - A list of integers for bit indexes.
                - A string for binary value of a bare integer value.
        """

        # The case where the operand is a bare integer
        if operand_string.count("[") == 0:
            return bin(int(operand_string))[2:]

        # The case where the operand is a collection of 1 or more bit indexes
        else:
            bit_indexes = []

            # Extracting all bit-indexes in the operand
            for part in operand_string.split("["):
                if len(part) > 1:
                    end_index = part.index("]")
                    bit_indexes.append(int(part[:end_index]))
            
            return bit_indexes